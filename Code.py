# -*- coding: utf-8 -*-
"""Assignment1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xSc-oQjmaLafdon08qOuodxMPCAsPrIJ
"""

import numpy as np
import pandas as pd
import sklearn as sklearn
import math
import matplotlib.pyplot as plt
from scipy.optimize import minimize,differential_evolution,Bounds,NonlinearConstraint,LinearConstraint,basinhopping
import sys

from google.colab import drive

drive.mount('/content/drive')
df = pd.read_csv('/content/drive/MyDrive/04_cricket_1999to2011.csv')

"""Using the first innings data alone in the above data set, find the best fit 'run production functions' in terms of wickets-in-hand w and overs-to-go u. Assume the model Z(u,w) = Z0(w)[1 - exp{-Lu/Z0(w)}]. Use the sum of squared errors loss function, summed across overs, wickets, and data points.

Note that your regression forces all slopes to be equal at u = 0. You should impose the conditions that L is nonnegative and the Z0(w)'s are ordered and nonnegative. You should provide a plot of the ten functions, and report the (11) parameters associated with the (10) production functions, and the normalised squared error (total squared error summed across overs, wickets, and data points, and normalised by the number of data points) in your pdf file.

Feel free to use tools for nonlinear regression available in Python. Some date fields are in different format with an extra comma. Write a short script to clean this up. This clean-up code should a part of the main program. You may create a temporary data file, but remove the temporary data file after the output data has been generated.
"""

#df=pd.read_csv("/content/04_cricket_1999to2011.csv")
inning1=df[df['Innings']==1]
inning1=inning1.set_index('Match')

#loss function
#Condition 1: L is nonnegative 
#Condition 2: Z0s are nonnegative and ordered
#Regression forces all slopes to be equal at u = 0
#Z=Z0(1-exp(-Lu/Z0))
#least square loss function = Z**2-y

#Z0 is an array with expected order is index0=>L,index1=>10 wickets remaining, index2=>9 wickets ..8 wickets...
#y is an 2D with w as rows
#N is the total number of data points used
#u_list is a list of overs played with order 10 w remaining, 9 w remianing ...st 1=>10,2=>9..

def objective(Z0,y,u_list,total_out): 
  res=0
  N=0
  res = 0
  for i in range(1, total_out + 1):
        overs_played=u_list[i]
        if not isinstance(overs_played, (list, tuple)):
            continue
        if len(overs_played)== 1: 
            overs_played = overs_played[0] 
            res+=(Z0[i]*(1-math.e**(-Z0[0]*overs_played/Z0[i]))-y[i])**2
            N+=1
        else:
          for j in range(len(overs_played)):
                over_played=overs_played[j]
                res+=(Z0[i]*(1-math.e**(-Z0[0]*over_played/Z0[i]))-y[i][j])**2
                N+=1
  if(N==0):
    N=1
  res/=N
  return res

#taking initial values of all 11 params to be 
Z0=np.array([10,275,230,200,170,130,100,90,80,70,30])
Z0_diff_evol=np.array([10,275,230,200,170,130,100,90,80,70,30])
Z0_basin=np.array([10,275,230,200,170,130,100,90,80,70,30])

mse=500.00000
mse_diff_evol=50000.00000
mse_basin=50000.00
for match_index in np.array(inning1.index.unique()):
    total_overs_played=inning1.loc[match_index]["Over"].max()
    total_out=inning1.loc[match_index]["Innings.Total.Out"].unique()[0]
    u=50-inning1.loc[match_index]["Over"] # Calculating overs in hand = a list of overs in hand for that specific match index
    u_list=[[] for _ in range(total_out+1)] #list with garbage 0 index values and other indices containing overs played in  (11-index)th wicket
    y=[0]*(total_out+1) #to keep a track of actual runs scored per the data/the ground truth ,again, 0th index is garbage  and rest of the indices containing a list of runs score for (11-index)th wicket
    for out_iterator in range(1,total_out+1):
      try:
        u_list[out_iterator]=(np.array(inning1[inning1['Total.Out']==11-out_iterator]['Over'].loc[match_index]))
        y[out_iterator]=np.array(inning1[inning1['Total.Out']==11-out_iterator]['Runs'].loc[match_index])
      except:
        continue
    bounds = Bounds([0] * 11, [700] * 11)
    bounds2 = [(0,700)]*11
    #A = np.diag([1] * 9, k=1) - np.diag([1] * 10, k=0)
    A=np.diag([1] * 10, k=0)-np.diag([1] * 9, k=1)
    b = np.zeros(10)
    a=lambda Z0: A @ Z0[1:] + b
    a_=lambda Z0_diff_evol: A @ Z0_diff_evol[1:] + b

    
    constraints2 = NonlinearConstraint(a, 0,np.inf)
    constraints2_ = NonlinearConstraint(a_, 0,np.inf)
    minimizer_kwargs = {"method": "trust-constr", "bounds": [(0, 700)]*len(Z0_basin),"args":(y,u_list,total_out)}
    result= minimize(objective, Z0,args=(y,u_list,total_out),method='trust-constr',constraints=constraints2)
    Z0=result.x
    mse=result.fun

    result2 = differential_evolution(func=objective, bounds=bounds2, args=(y,u_list,total_out),x0=Z0_diff_evol,constraints=constraints2_,maxiter=10)
    Z0_diff_evol=result2.x
    mse_diff_evol=result2.fun

    res_basin = basinhopping(func=objective, x0=Z0_basin, minimizer_kwargs=minimizer_kwargs,niter=10)
    Z0_basin=res_basin.x
    mse_basin=res_basin.fun

print("###1#### Local Optimisation Parameters : ",Z0," mse:",mse,"######")

print("###1#### Differential Evolution Optimisation Parameters : ",Z0_diff_evol," mse:",mse_diff_evol,"######")

print("###1#### Basinhoping Optimisation Parameters : ",Z0_basin," mse:",mse_basin,"######")

#Plots
fig,ax=plt.subplots(3,1,figsize=(10,20))
fig.subplots_adjust(wspace=0.5)
x=np.arange(50, -1, -1)
ax[0].set_xlabel("Overs Remaining")
ax[0].set_ylabel("Average Runs obtainable")
ax[0].set_title("Local Optimization using minimization")
ax[1].set_xlabel("Overs Remaining")
ax[1].set_ylabel("Average Runs obtainable")
ax[1].set_title("Global Optimization using Differential evolution")
ax[2].set_xlabel("Overs Remaining")
ax[2].set_ylabel("Average Runs obtainable")
ax[2].set_title("Global Optimization using Basinhopping")
for Z0_index in range(1,len(Z0)):
  y=Z0[Z0_index]*(1-math.e**(-Z0[0]*x/Z0[Z0_index]))
  y2=Z0_diff_evol[Z0_index]*(1-math.e**(-Z0_diff_evol[0]*x/Z0_diff_evol[Z0_index]))
  y3=Z0_basin[Z0_index]*(1-math.e**(-Z0_basin[0]*x/Z0_basin[Z0_index]))
  ax[0].plot(x,y)
  ax[1].plot(x,y2)
  ax[2].plot(x,y3)
ax[0].legend(["Z0[10]","Z0[9]","Z0[8]","Z0[7]","Z0[6]","Z0[5]","Z0[4]","Z0[3]","Z0[2]","Z0[1]"],bbox_to_anchor=(1.05, 1))
ax[1].legend(["Z0[10]","Z0[9]","Z0[8]","Z0[7]","Z0[6]","Z0[5]","Z0[4]","Z0[3]","Z0[2]","Z0[1]"],bbox_to_anchor=(1.05, 1))
ax[2].legend(["Z0[10]","Z0[9]","Z0[8]","Z0[7]","Z0[6]","Z0[5]","Z0[4]","Z0[3]","Z0[2]","Z0[1]"],bbox_to_anchor=(1.05, 1))

